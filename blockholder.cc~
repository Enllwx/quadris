#include <vector>
#include <iostream>
#include "blockholder.h"
#include "grid.h"

BlockHolder::BlockHolder(Grid *g):
  theGrid{g}, levelZero{LevelZero()}
{
  //for(int i=0; i<Level::maxLvl; ++i) level[i]->setGrid(g);
  //Difficulty z = LevelZero(g);
  levels.emplace_back(&levelZero);
  //level[Level::lvl0] = levelZero;
  levelZero.setGrid(g);

  currentBlock = levelZero.newBlock();//getDifficulty(g->getDifficulty()).newBlock();//level[g->getDifficulty()]->newBlock();
}

Difficulty* BlockHolder::getDifficulty(Level lvl){
  return levels[lvl];
}

// return the type of next block
Shape BlockHolder::nextBlockType() const {}//const { return nextBlock->type; }

Block BlockHolder::getCurrentBlock(){ return currentBlock; }

// mutate the current block
void BlockHolder::mutate(Move cmd, const int num){
  for(int i=0; i<num; ++i){
    switch(cmd){
      case Move::Left :
        currentBlock = getDifficulty(theGrid->getDifficulty())->moveLeft(currentBlock);
        break;
      case Move::Right :
        currentBlock = getDifficulty(theGrid->getDifficulty())->moveRight(currentBlock);
        break;
      case Move::Down :
        currentBlock =  getDifficulty(theGrid->getDifficulty())->moveDown(currentBlock);
        break;
      case Move::Drop :
        currentBlock = getDifficulty(theGrid->getDifficulty())->drop(currentBlock);
        break;
      case Move::CounterRotate :
        currentBlock = getDifficulty(theGrid->getDifficulty())->rotateCounter(currentBlock);
        break;
      case Move::Rotate :
        currentBlock = getDifficulty(theGrid->getDifficulty())->rotateClock(currentBlock);
        break;
    }
  } theGrid->update();
}

// give hint for current block
void BlockHolder::hint(){

}

void BlockHolder::clear(){
}

bool BlockHolder::gameOver(){
  return false;
}
